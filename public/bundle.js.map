{"version":3,"file":"bundle.js","sources":["../node_modules/svelte/internal.mjs","../src/Image.svelte","../node_modules/svelte/store.mjs","../src/stores.js","../node_modules/svelte/easing.mjs","../node_modules/svelte/transition.mjs","../src/GalleryExpanded.svelte","../src/GalleryStack.svelte","../src/App.svelte","../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction validate_store(store, name) {\n    if (!store || typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(component, store, callback) {\n    const unsub = store.subscribe(callback);\n    component.$$.on_destroy.push(unsub.unsubscribe\n        ? () => unsub.unsubscribe()\n        : unsub);\n}\nfunction create_slot(definition, ctx, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, fn) {\n    return definition[1]\n        ? assign({}, assign(ctx.$$scope.ctx, definition[1](fn ? fn(ctx) : {})))\n        : ctx.$$scope.ctx;\n}\nfunction get_slot_changes(definition, ctx, changed, fn) {\n    return definition[1]\n        ? assign({}, assign(ctx.$$scope.changed || {}, definition[1](fn ? fn(changed) : {})))\n        : ctx.$$scope.changed || {};\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? requestAnimationFrame : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nlet running = false;\nfunction run_tasks() {\n    tasks.forEach(task => {\n        if (!task[0](now())) {\n            tasks.delete(task);\n            task[1]();\n        }\n    });\n    running = tasks.size > 0;\n    if (running)\n        raf(run_tasks);\n}\nfunction clear_loops() {\n    // for testing...\n    tasks.forEach(task => tasks.delete(task));\n    running = false;\n}\nfunction loop(fn) {\n    let task;\n    if (!running) {\n        running = true;\n        raf(run_tasks);\n    }\n    return {\n        promise: new Promise(fulfil => {\n            tasks.add(task = [fn, fulfil]);\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction detach_between(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        before.parentNode.removeChild(before.nextSibling);\n    }\n}\nfunction detach_before(after) {\n    while (after.previousSibling) {\n        after.parentNode.removeChild(after.previousSibling);\n    }\n}\nfunction detach_after(before) {\n    while (before.nextSibling) {\n        before.parentNode.removeChild(before.nextSibling);\n    }\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    for (const key in attributes) {\n        if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key in node) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group) {\n    const value = [];\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.push(group[i].__value);\n    }\n    return value;\n}\nfunction to_number(value) {\n    return value === '' ? undefined : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction claim_element(nodes, name, attributes, svg) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeName === name) {\n            for (let j = 0; j < node.attributes.length; j += 1) {\n                const attribute = node.attributes[j];\n                if (!attributes[attribute.name])\n                    node.removeAttribute(attribute.name);\n            }\n            return nodes.splice(i, 1)[0]; // TODO strip unwanted attributes\n        }\n    }\n    return svg ? svg_element(name) : element(name);\n}\nfunction claim_text(nodes, data) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 3) {\n            node.data = data;\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return text(data);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.data !== data)\n        text.data = data;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value) {\n    node.style.setProperty(key, value);\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\nfunction add_resize_listener(element, fn) {\n    if (getComputedStyle(element).position === 'static') {\n        element.style.position = 'relative';\n    }\n    const object = document.createElement('object');\n    object.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;');\n    object.type = 'text/html';\n    let win;\n    object.onload = () => {\n        win = object.contentDocument.defaultView;\n        win.addEventListener('resize', fn);\n    };\n    if (/Trident/.test(navigator.userAgent)) {\n        element.appendChild(object);\n        object.data = 'about:blank';\n    }\n    else {\n        object.data = 'about:blank';\n        element.appendChild(object);\n    }\n    return {\n        cancel: () => {\n            win && win.removeEventListener && win.removeEventListener('resize', fn);\n            element.removeChild(object);\n        }\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, false, false, detail);\n    return e;\n}\n\nlet stylesheet;\nlet active = 0;\nlet current_rules = {};\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    if (!current_rules[name]) {\n        if (!stylesheet) {\n            const style = element('style');\n            document.head.appendChild(style);\n            stylesheet = style.sheet;\n        }\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    node.style.animation = (node.style.animation || '')\n        .split(', ')\n        .filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    )\n        .join(', ');\n    if (name && !--active)\n        clear_rules();\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        let i = stylesheet.cssRules.length;\n        while (i--)\n            stylesheet.deleteRule(i);\n        current_rules = {};\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, start: start_time = now() + delay, end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now$$1 => {\n        if (!started && now$$1 >= start_time) {\n            started = true;\n        }\n        if (started && now$$1 >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now$$1 - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        const b = node.getBoundingClientRect();\n        if (a.left !== b.left || a.top !== b.top) {\n            const style = getComputedStyle(node);\n            const transform = style.transform === 'none' ? '' : style.transform;\n            node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n        }\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error(`Function called outside component initialization`);\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_render.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_render.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = current_component;\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        callbacks.slice().forEach(fn => fn(event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_binding_callback(fn) {\n    binding_callbacks.push(fn);\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nfunction flush() {\n    const seen_callbacks = new Set();\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        while (dirty_components.length) {\n            const component = dirty_components.shift();\n            set_current_component(component);\n            update(component.$$);\n        }\n        while (binding_callbacks.length)\n            binding_callbacks.shift()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        while (render_callbacks.length) {\n            const callback = render_callbacks.pop();\n            if (!seen_callbacks.has(callback)) {\n                callback();\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n            }\n        }\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n}\nfunction update($$) {\n    if ($$.fragment) {\n        $$.update($$.dirty);\n        run_all($$.before_render);\n        $$.fragment.p($$.dirty, $$.ctx);\n        $$.dirty = null;\n        $$.after_render.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nlet outros;\nfunction group_outros() {\n    outros = {\n        remaining: 0,\n        callbacks: []\n    };\n}\nfunction check_outros() {\n    if (!outros.remaining) {\n        run_all(outros.callbacks);\n    }\n}\nfunction on_outro(callback) {\n    outros.callbacks.push(callback);\n}\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick: tick$$1 = noop, css } = config;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick$$1(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        task = loop(now$$1 => {\n            if (running) {\n                if (now$$1 >= end_time) {\n                    tick$$1(1, 0);\n                    cleanup();\n                    return running = false;\n                }\n                if (now$$1 >= start_time) {\n                    const t = easing((now$$1 - start_time) / duration);\n                    tick$$1(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            delete_rule(node);\n            if (typeof config === 'function') {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.remaining += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick: tick$$1 = noop, css } = config;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        loop(now$$1 => {\n            if (running) {\n                if (now$$1 >= end_time) {\n                    tick$$1(0, 1);\n                    if (!--group.remaining) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.callbacks);\n                    }\n                    return false;\n                }\n                if (now$$1 >= start_time) {\n                    const t = easing((now$$1 - start_time) / duration);\n                    tick$$1(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (typeof config === 'function') {\n        wait().then(() => {\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = program.b - t;\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick: tick$$1 = noop, css } = config;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.remaining += 1;\n        }\n        if (running_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick$$1(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now$$1 => {\n                if (pending_program && now$$1 > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now$$1 >= running_program.end) {\n                        tick$$1(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.remaining)\n                                    run_all(running_program.group.callbacks);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now$$1 >= running_program.start) {\n                        const p = now$$1 - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick$$1(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (typeof config === 'function') {\n                wait().then(() => {\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = key && { [key]: value };\n        const child_ctx = assign(assign({}, info.ctx), info.resolved);\n        const block = type && (info.current = type)(child_ctx);\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        on_outro(() => {\n                            block.d(1);\n                            info.blocks[i] = null;\n                        });\n                        block.o(1);\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            if (block.i)\n                block.i(1);\n            block.m(info.mount(), info.anchor);\n            flush();\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n    }\n    if (is_promise(promise)) {\n        promise.then(value => {\n            update(info.then, 1, info.value, value);\n        }, error => {\n            update(info.catch, 2, info.error, error);\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = { [info.value]: promise };\n    }\n}\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    on_outro(() => {\n        destroy_block(block, lookup);\n    });\n    block.o(1);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, changed, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(changed, child_ctx);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        if (block.i)\n            block.i(1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction measure(blocks) {\n    const rects = {};\n    let i = blocks.length;\n    while (i--)\n        rects[blocks[i].key] = blocks[i].node.getBoundingClientRect();\n    return rects;\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args) {\n    const attributes = Object.assign({}, ...args);\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === undefined)\n            return;\n        if (value === true)\n            str += \" \" + name;\n        const escaped = String(value)\n            .replace(/\"/g, '&#34;')\n            .replace(/'/g, '&#39;');\n        str += \" \" + name + \"=\" + JSON.stringify(escaped);\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_render: [],\n            after_render: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, options = {}) => {\n            on_destroy = [];\n            const result = { head: '', css: new Set() };\n            const html = $$render(result, props, {}, options);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.head\n            };\n        },\n        $$render\n    };\n}\nfunction get_store_value(store) {\n    let value;\n    store.subscribe(_ => value = _)();\n    return value;\n}\n\nfunction bind(component, name, callback) {\n    if (component.$$.props.indexOf(name) === -1)\n        return;\n    component.$$.bound[name] = callback;\n    callback(component.$$.ctx[name]);\n}\nfunction mount_component(component, target, anchor) {\n    const { fragment, on_mount, on_destroy, after_render } = component.$$;\n    fragment.m(target, anchor);\n    // onMount happens after the initial afterUpdate. Because\n    // afterUpdate callbacks happen in reverse order (inner first)\n    // we schedule onMount callbacks before afterUpdate callbacks\n    add_render_callback(() => {\n        const new_on_destroy = on_mount.map(run).filter(is_function);\n        if (on_destroy) {\n            on_destroy.push(...new_on_destroy);\n        }\n        else {\n            // Edge case - component was destroyed immediately,\n            // most likely as a result of a binding initialising\n            run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n    });\n    after_render.forEach(add_render_callback);\n}\nfunction destroy(component, detaching) {\n    if (component.$$) {\n        run_all(component.$$.on_destroy);\n        component.$$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        component.$$.on_destroy = component.$$.fragment = null;\n        component.$$.ctx = {};\n    }\n}\nfunction make_dirty(component, key) {\n    if (!component.$$.dirty) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty = blank_object();\n    }\n    component.$$.dirty[key] = true;\n}\nfunction init(component, options, instance, create_fragment, not_equal$$1, prop_names) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const props = options.props || {};\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props: prop_names,\n        update: noop,\n        not_equal: not_equal$$1,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        before_render: [],\n        after_render: [],\n        context: new Map(parent_component ? parent_component.$$.context : []),\n        // everything else\n        callbacks: blank_object(),\n        dirty: null\n    };\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, props, (key, value) => {\n            if ($$.ctx && not_equal$$1($$.ctx[key], $$.ctx[key] = value)) {\n                if ($$.bound[key])\n                    $$.bound[key](value);\n                if (ready)\n                    make_dirty(component, key);\n            }\n        })\n        : props;\n    $$.update();\n    ready = true;\n    run_all($$.before_render);\n    $$.fragment = create_fragment($$.ctx);\n    if (options.target) {\n        if (options.hydrate) {\n            $$.fragment.l(children(options.target));\n        }\n        else {\n            $$.fragment.c();\n        }\n        if (options.intro && component.$$.fragment.i)\n            component.$$.fragment.i();\n        mount_component(component, options.target, options.anchor);\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement !== 'undefined') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr$$1, oldValue, newValue) {\n            this[attr$$1] = newValue;\n        }\n        $destroy() {\n            destroy(this, true);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set() {\n            // overridden by instance, if it has props\n        }\n    };\n}\nclass SvelteComponent {\n    $destroy() {\n        destroy(this, true);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set() {\n        // overridden by instance, if it has props\n    }\n}\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(`'target' is a required option`);\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn(`Component was already destroyed`); // eslint-disable-line no-console\n        };\n    }\n}\n\nexport { create_animation, fix_position, handle_promise, append, insert, detach, detach_between, detach_before, detach_after, destroy_each, element, object_without_properties, svg_element, text, space, empty, listen, prevent_default, stop_propagation, attr, set_attributes, set_custom_element_data, xlink_attr, get_binding_group_value, to_number, time_ranges_to_array, children, claim_element, claim_text, set_data, set_input_type, set_style, select_option, select_options, select_value, select_multiple_value, add_resize_listener, toggle_class, custom_event, destroy_block, outro_and_destroy_block, fix_and_outro_and_destroy_block, update_keyed_each, measure, current_component, set_current_component, beforeUpdate, onMount, afterUpdate, onDestroy, createEventDispatcher, setContext, getContext, bubble, clear_loops, loop, dirty_components, intros, schedule_update, tick, add_binding_callback, add_render_callback, add_flush_callback, flush, get_spread_update, invalid_attribute_name_character, spread, escaped, escape, each, missing_component, validate_component, debug, create_ssr_component, get_store_value, group_outros, check_outros, on_outro, create_in_transition, create_out_transition, create_bidirectional_transition, noop, identity, assign, is_promise, add_location, run, blank_object, run_all, is_function, safe_not_equal, not_equal, validate_store, subscribe, create_slot, get_slot_context, get_slot_changes, exclude_internal_props, now, raf, set_now, set_raf, bind, mount_component, init, SvelteElement, SvelteComponent, SvelteComponentDev };\n","<script>\n  // This handles the lazy loading of images, or the best I could copy or come up with\n  import { onMount } from 'svelte';\n  import { createEventDispatcher } from 'svelte';\n  export let image;\n  export let visible = 0;\n\n  let height;\n  let width;\n  const dispatch = createEventDispatcher();\n\n  onMount(async () => {\n    const res = await fetch(image);\n    if(res.status === 200){\n       image = res.url;\n       const loader = new Image();\n       loader.onload = () => {\n         visible = true;\n         height = loader.height;\n         width = loader.width;\n         dispatch('loadingComplete', {\n          loadingComplete: 1\n         });\n       }\n       loader.src = image;\n    }else{\n      visible = false\n    }\n  });\n  \n</script>\n\n<style>\n  .opacity--0{\n    opacity: 0;\n  }\n  .loader{\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    background: rgba(0,0,0,0.04);\n    z-index: 11;\n    left: 0;\n    display: block;\n    transition: 0.2s all;\n    /* animation: loading 4s infinite linear; */\n    pointer-events: none;\n    overflow: hidden;\n  }\n\n  .inner{\n    width: 300%;\n    height: 300%;\n    top: 0 ; left: 0;\n    animation: shimmer 3s linear infinite;\n    background: linear-gradient(to right, rgba(0,0,0,0.03) 0%, rgba(0,0,0,0.1) 90%,rgba(0,0,0,0.1) 95%, rgba(0,0,0,0) 100%);\n  }\n\n  img{\n    display: block;\n    object-fit: cover;\n    transition: 0.4s all ease-out;\n    justify-self: center;\n    align-self: center;\n    min-width: 100%;\n    min-height: 100%;\n    width: 100%;\n    height: 100%;\n  }\n  @keyframes shimmer {\n    0%{\n      transform: rotate(-15deg) translateX(-100%) translateY(-50%);\n    }\n    100%{\n      transform: rotate(-15deg) translateX(100%) translateY(-50%);\n    }\n  }\n  @keyframes loading{\n    0%{\n      height: 0%;\n      top: auto;\n      bottom: 0;\n    }\n    50%{\n      height: 100%;\n      top: auto;\n      bottom: 0;\n    }\n    51%{\n      top: 0;\n      bottom: auto;\n      height: 100%;\n    }\n    100%{\n      top: 0;\n      bottom: auto;\n      height: 0%;\n    }\n  }\n</style>\n\n<img src=\"{image}\" alt=\"\" class=\"{visible ? '' : 'opacity--0'}\">\n{#if !visible}\n  <div class=\"loader\">\n    <div class=\"inner\"></div>\n  </div>\n{/if}\n\n\n\n","import { noop, safe_not_equal, run_all, is_function } from './internal';\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe,\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = [];\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (!stop) {\n                return; // not ready\n            }\n            subscribers.forEach((s) => s[1]());\n            subscribers.forEach((s) => s[0](value));\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.push(subscriber);\n        if (subscribers.length === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            const index = subscribers.indexOf(subscriber);\n            if (index !== -1) {\n                subscribers.splice(index, 1);\n            }\n            if (subscribers.length === 0) {\n                stop();\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n * @param {Stores} stores input stores\n * @param {function(Stores=, function(*)=):*}fn function callback that aggregates the values\n * @param {*=}initial_value when used asynchronously\n */\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => store.subscribe((value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n * @param store readable\n */\nfunction get(store) {\n    let value;\n    store.subscribe((_) => value = _)();\n    return value;\n}\n\nexport { readable, writable, derived, get };\n","import { writable } from 'svelte/store';\nexport const destroyingExpandedGallery = writable(false);\nexport const activeCollection = writable(0);\nexport const loadingSecondary = writable(false);","export { identity as linear } from './internal';\n\n/*\nAdapted from https://github.com/mattdesl\nDistributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md\n*/\nfunction backInOut(t) {\n    const s = 1.70158 * 1.525;\n    if ((t *= 2) < 1)\n        return 0.5 * (t * t * ((s + 1) * t - s));\n    return 0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2);\n}\nfunction backIn(t) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n}\nfunction backOut(t) {\n    const s = 1.70158;\n    return --t * t * ((s + 1) * t + s) + 1;\n}\nfunction bounceOut(t) {\n    const a = 4.0 / 11.0;\n    const b = 8.0 / 11.0;\n    const c = 9.0 / 10.0;\n    const ca = 4356.0 / 361.0;\n    const cb = 35442.0 / 1805.0;\n    const cc = 16061.0 / 1805.0;\n    const t2 = t * t;\n    return t < a\n        ? 7.5625 * t2\n        : t < b\n            ? 9.075 * t2 - 9.9 * t + 3.4\n            : t < c\n                ? ca * t2 - cb * t + cc\n                : 10.8 * t * t - 20.52 * t + 10.72;\n}\nfunction bounceInOut(t) {\n    return t < 0.5\n        ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\n        : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\nfunction bounceIn(t) {\n    return 1.0 - bounceOut(1.0 - t);\n}\nfunction circInOut(t) {\n    if ((t *= 2) < 1)\n        return -0.5 * (Math.sqrt(1 - t * t) - 1);\n    return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n}\nfunction circIn(t) {\n    return 1.0 - Math.sqrt(1.0 - t * t);\n}\nfunction circOut(t) {\n    return Math.sqrt(1 - --t * t);\n}\nfunction cubicInOut(t) {\n    return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\nfunction cubicIn(t) {\n    return t * t * t;\n}\nfunction cubicOut(t) {\n    const f = t - 1.0;\n    return f * f * f + 1.0;\n}\nfunction elasticInOut(t) {\n    return t < 0.5\n        ? 0.5 *\n            Math.sin(((+13.0 * Math.PI) / 2) * 2.0 * t) *\n            Math.pow(2.0, 10.0 * (2.0 * t - 1.0))\n        : 0.5 *\n            Math.sin(((-13.0 * Math.PI) / 2) * (2.0 * t - 1.0 + 1.0)) *\n            Math.pow(2.0, -10.0 * (2.0 * t - 1.0)) +\n            1.0;\n}\nfunction elasticIn(t) {\n    return Math.sin((13.0 * t * Math.PI) / 2) * Math.pow(2.0, 10.0 * (t - 1.0));\n}\nfunction elasticOut(t) {\n    return (Math.sin((-13.0 * (t + 1.0) * Math.PI) / 2) * Math.pow(2.0, -10.0 * t) + 1.0);\n}\nfunction expoInOut(t) {\n    return t === 0.0 || t === 1.0\n        ? t\n        : t < 0.5\n            ? +0.5 * Math.pow(2.0, 20.0 * t - 10.0)\n            : -0.5 * Math.pow(2.0, 10.0 - t * 20.0) + 1.0;\n}\nfunction expoIn(t) {\n    return t === 0.0 ? t : Math.pow(2.0, 10.0 * (t - 1.0));\n}\nfunction expoOut(t) {\n    return t === 1.0 ? t : 1.0 - Math.pow(2.0, -10.0 * t);\n}\nfunction quadInOut(t) {\n    t /= 0.5;\n    if (t < 1)\n        return 0.5 * t * t;\n    t--;\n    return -0.5 * (t * (t - 2) - 1);\n}\nfunction quadIn(t) {\n    return t * t;\n}\nfunction quadOut(t) {\n    return -t * (t - 2.0);\n}\nfunction quartInOut(t) {\n    return t < 0.5\n        ? +8.0 * Math.pow(t, 4.0)\n        : -8.0 * Math.pow(t - 1.0, 4.0) + 1.0;\n}\nfunction quartIn(t) {\n    return Math.pow(t, 4.0);\n}\nfunction quartOut(t) {\n    return Math.pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\n}\nfunction quintInOut(t) {\n    if ((t *= 2) < 1)\n        return 0.5 * t * t * t * t * t;\n    return 0.5 * ((t -= 2) * t * t * t * t + 2);\n}\nfunction quintIn(t) {\n    return t * t * t * t * t;\n}\nfunction quintOut(t) {\n    return --t * t * t * t * t + 1;\n}\nfunction sineInOut(t) {\n    return -0.5 * (Math.cos(Math.PI * t) - 1);\n}\nfunction sineIn(t) {\n    const v = Math.cos(t * Math.PI * 0.5);\n    if (Math.abs(v) < 1e-14)\n        return 1;\n    else\n        return 1 - v;\n}\nfunction sineOut(t) {\n    return Math.sin((t * Math.PI) / 2);\n}\n\nexport { backInOut, backIn, backOut, bounceOut, bounceInOut, bounceIn, circInOut, circIn, circOut, cubicInOut, cubicIn, cubicOut, elasticInOut, elasticIn, elasticOut, expoInOut, expoIn, expoOut, quadInOut, quadIn, quadOut, quartInOut, quartIn, quartOut, quintInOut, quintIn, quintOut, sineInOut, sineIn, sineOut };\n","import { cubicOut, cubicInOut } from './easing';\nimport { is_function, assign } from './internal';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\n\nfunction fade(node, { delay = 0, duration = 400 }) {\n    const o = +getComputedStyle(node).opacity;\n    return {\n        delay,\n        duration,\n        css: t => `opacity: ${t * o}`\n    };\n}\nfunction fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 }) {\n    const style = getComputedStyle(node);\n    const target_opacity = +style.opacity;\n    const transform = style.transform === 'none' ? '' : style.transform;\n    const od = target_opacity * (1 - opacity);\n    return {\n        delay,\n        duration,\n        easing,\n        css: (t, u) => `\n\t\t\ttransform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);\n\t\t\topacity: ${target_opacity - (od * u)}`\n    };\n}\nfunction slide(node, { delay = 0, duration = 400, easing = cubicOut }) {\n    const style = getComputedStyle(node);\n    const opacity = +style.opacity;\n    const height = parseFloat(style.height);\n    const padding_top = parseFloat(style.paddingTop);\n    const padding_bottom = parseFloat(style.paddingBottom);\n    const margin_top = parseFloat(style.marginTop);\n    const margin_bottom = parseFloat(style.marginBottom);\n    const border_top_width = parseFloat(style.borderTopWidth);\n    const border_bottom_width = parseFloat(style.borderBottomWidth);\n    return {\n        delay,\n        duration,\n        easing,\n        css: t => `overflow: hidden;` +\n            `opacity: ${Math.min(t * 20, 1) * opacity};` +\n            `height: ${t * height}px;` +\n            `padding-top: ${t * padding_top}px;` +\n            `padding-bottom: ${t * padding_bottom}px;` +\n            `margin-top: ${t * margin_top}px;` +\n            `margin-bottom: ${t * margin_bottom}px;` +\n            `border-top-width: ${t * border_top_width}px;` +\n            `border-bottom-width: ${t * border_bottom_width}px;`\n    };\n}\nfunction scale(node, { delay = 0, duration = 400, easing = cubicOut, start = 0, opacity = 0 }) {\n    const style = getComputedStyle(node);\n    const target_opacity = +style.opacity;\n    const transform = style.transform === 'none' ? '' : style.transform;\n    const sd = 1 - start;\n    const od = target_opacity * (1 - opacity);\n    return {\n        delay,\n        duration,\n        easing,\n        css: (t, u) => `\n\t\t\ttransform: ${transform} scale(${1 - (sd * u)});\n\t\t\topacity: ${target_opacity - (od * u)}\n\t\t`\n    };\n}\nfunction draw(node, { delay = 0, speed, duration, easing = cubicInOut }) {\n    const len = node.getTotalLength();\n    if (duration === undefined) {\n        if (speed === undefined) {\n            duration = 800;\n        }\n        else {\n            duration = len / speed;\n        }\n    }\n    else if (typeof duration === 'function') {\n        duration = duration(len);\n    }\n    return {\n        delay,\n        duration,\n        easing,\n        css: (t, u) => `stroke-dasharray: ${t * len} ${u * len}`\n    };\n}\nfunction crossfade(_a) {\n    var { fallback } = _a, defaults = __rest(_a, [\"fallback\"]);\n    const to_receive = new Map();\n    const to_send = new Map();\n    function crossfade(from, node, params) {\n        const { delay = 0, duration = d => Math.sqrt(d) * 30, easing = cubicOut } = assign(assign({}, defaults), params);\n        const to = node.getBoundingClientRect();\n        const dx = from.left - to.left;\n        const dy = from.top - to.top;\n        const d = Math.sqrt(dx * dx + dy * dy);\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        const opacity = +style.opacity;\n        return {\n            delay,\n            duration: is_function(duration) ? duration(d) : duration,\n            easing,\n            css: (t, u) => `\n\t\t\t\topacity: ${t * opacity};\n\t\t\t\ttransform: ${transform} translate(${u * dx}px,${u * dy}px);\n\t\t\t`\n        };\n    }\n    function transition(items, counterparts, intro) {\n        return (node, params) => {\n            items.set(params.key, {\n                rect: node.getBoundingClientRect()\n            });\n            return () => {\n                if (counterparts.has(params.key)) {\n                    const { rect } = counterparts.get(params.key);\n                    counterparts.delete(params.key);\n                    return crossfade(rect, node, params);\n                }\n                // if the node is disappearing altogether\n                // (i.e. wasn't claimed by the other list)\n                // then we need to supply an outro\n                items.delete(params.key);\n                return fallback && fallback(node, params, intro);\n            };\n        };\n    }\n    return [\n        transition(to_send, to_receive, false),\n        transition(to_receive, to_send, true)\n    ];\n}\n\nexport { fade, fly, slide, scale, draw, crossfade };\n","<script>\n  // This component expands the stack to show all images within the stack\n  // and then loads higher res images (if user clicks an image) and displays \n  // them in a prev/next style lightbox.\n\n  import Image from './Image.svelte';\n  import Spinner from './Spinner.svelte';\n  import { onMount, afterUpdate, onDestroy, createEventDispatcher } from 'svelte';\n  import { destroyingExpandedGallery, loadingSecondary } from './stores.js';\n  import { fade } from 'svelte/transition';\n  //import { _resetStacks } from './GalleryStack.svelte';\n\n  export let stack;\n  export let lowresdir;\n  export let hiresdir;\n  export let originaltarget;\n\n  const dispatch = createEventDispatcher();\n\n  // references to divs\n  let activeCollection;\n  let thirdLevel;\n\n  // placeholders for objects that we'll iterate over\n  let images;\n  let hiresImages;\n  let currentTitle;\n\n  // indexes of the current image (why are there two??)\n  let current;\n\n  // Scroll position stuff\n  let y;\n  let originalScrollPos;\n  let hiresScrollPos;\n\n  // x + y for center of document\n  let centerX = document.documentElement.clientWidth/2;\n  let centerY = document.documentElement.clientHeight/2;\n\n  // Offset transition distance for hi-res lightbox \n  let offset = 25;\n  \n  // Handles transition of single gallery image when it transitions to hi-res.\n  let transitionHandler;\n  \n  // count for loading\n  let count = 0;\n\n  // booleans, do I need so many?\n  let showTitles          = true;\n  let hiresLoaded         = false;\n  let ready               = false;\n  let loadedSuccessfully  = false;\n  let expandedOnce        = false;\n  let transitioning       = false;\n  let closedGallery       = false;\n  \n  // could probably remove the need for this?\n  const sleep = msec => new Promise(resolve => setTimeout(resolve, msec));\n\n  // want a reference to each gallery items within the active Collection.\n  onMount(() => {\n    images = activeCollection.getElementsByClassName('galleryitem');  \n    // want the item in a stack on first mount\n    attemptToConsolidate();\n    \n  });\n\n  // Might be able to refactor this to not use AfterUpdate, \n  // but for now it seems ok.\n  afterUpdate(() => {\n    if(!$loadingSecondary && !$destroyingExpandedGallery && !expandedOnce){\n      expandStuff();\n      expandedOnce = true;\n    }\n    if($destroyingExpandedGallery && expandedOnce){\n      attemptToConsolidate();\n      expandedOnce = false;\n    }\n  });\n\n  onDestroy(() => {\n    console.log('being destroyed... laters');\n    destroyingExpandedGallery.update(n => false);\n  });\n\n  // could the following two function be consolidated into one?\n  function handleLoadingComplete(event){\n    count = count + event.detail.loadingComplete;\n    if(count === stack.length){\n      count = 0;\n      loadedSuccessfully = true;\n    }\n  }\n\n  function handleLoadingHiResComplete(event){\n    count = count + event.detail.loadingComplete;\n    if(count === stack.length){\n      count = 0;\n      hiresLoaded = true;\n    }\n    hiresImages = thirdLevel.getElementsByClassName('hi-image');\n  }\n\n  // Keyboard functionality.\n  function handleKeydown(event){\n    if(event.code == \"ArrowRight\"){\n      showNext();\n    }\n    if(event.code == \"ArrowLeft\"){\n      showPrevious();\n    }\n    if(event.code == \"Escape\"){\n      if(!closedGallery){\n        closeGallery();\n      }else{\n        document.getElementById(\"breadcrumb\").click();\n      }\n    }\n  }\n\n  // This is called on click of gallery item, to init the lightbox.\n  function loadLargeImages(event, index){\n    current = index;\n    event.preventDefault();\n\n    // animates clicked image into center of screen.\n    animateClicked(current);\n\n    // Gets the hi-res images into the DOM and loading\n    ready = true;\n  }\n  \n  // Function for bringing everything together. called onMount\n  // and when gallery is being destroyed.\n  function attemptToConsolidate(){\n    activeCollection.classList.add('no-pointer-events');\n\n    //sometimes the object is undefined I don't know why.\n    if(images !== undefined){\n      console.log(\"weren't me guv, everything normal...\");\n      performConsolidation();\n    \n    // not sure I'm even experiencing this bug anymore, but can't hurt to be sure?\n    }else{\n      console.log('object was undefined, hard luck son.');\n      \n      // Try again?\n      (async () => {\n        await sleep(180);\n        Object.entries(images).forEach(([key, value]) => {\n          console.log('trying again...');\n          performConsolidation();\n        });\n      })();\n    }\n  }\n\n  // sometimes the object is empty, so we want a function that only runs when the object is there.\n  // This is only called by the attemptToConsolidate function.\n  function performConsolidation(){\n    let rect = originaltarget.getBoundingClientRect();\n    \n    Object.entries(images).forEach(([key, value]) => {\n      let imageDivRect = value.getBoundingClientRect();\n      let transformedStyle = `translateX(${(rect.x + 4) - imageDivRect.x}px) translateY(${(rect.y + 4) - imageDivRect.y}px) rotate(${key * 4}deg)`;\n      \n      // If first image\n      if(key == 0){\n        transformedStyle = `translateX(${(rect.x + 4) - imageDivRect.x}px) translateY(${(rect.y + 6) - imageDivRect.y}px) scale(1.08) translateY(5px) rotate(-2deg)`;\n      }\n      \n      // stacks the zindex's of images so first is always on top.\n      value.style.zIndex = images.length - key;\n\n      // if gallery is being closed/destroyed we want a quicker transition.\n      if($destroyingExpandedGallery){\n\n        // Scroll to position we were at when item was first clicked.\n        window.scrollTo(0, originalScrollPos);\n        activeCollection.style.transform = `translateY(0px)`;\n        transformedStyle = `translateX(${rect.x - imageDivRect.x}px) translateY(${rect.y - imageDivRect.y}px) rotate(${key * 2}deg)`;\n        // Quick transition please.\n        value.classList.add('quicktransition');\n        // Set tranformed style (different if destroying)\n        value.style.transform = transformedStyle;\n\n      }else{\n        // Set tranformed style.\n        value.style.transform = transformedStyle;\n      }\n      \n    });\n  }\n\n  // Function for Expanding things into place.  \n  function expandStuff(){\n    \n    // Want items that are expanded to always be at the top of the viewport\n    originalScrollPos = scrollY;\n    window.scrollTo(0,0);\n    activeCollection.style.transform = `translateY(-${originalScrollPos}px)`;\n  \n    (async () => {\n      // Need to wait a little bit after scrollTo.\n      await sleep(80);\n      Object.entries(images).forEach(([key, value]) => {\n        var imageDivRect = value.getBoundingClientRect();\n        transitioning = true;\n        value.classList.add('slowtransition');\n        value.style.transform = `translateX(0px) translateY(${originalScrollPos}px)`; //translateY(${originalScrollPos}px)`;\n      });\n    })();\n\n    (async () => {\n      // sleep to wait for transition to end, maybe better to use transitionend ?\n      await sleep(500);\n      activeCollection.classList.remove('no-pointer-events');\n      transitioning = false;\n    })();\n  }\n\n  // animate clicked image to the center.\n  function animateClicked(current){\n    // This could probably be done more accurately, but it works ok for now.\n    let currentImage = images[current].getElementsByTagName('img')[0];\n    let rect = images[current].getBoundingClientRect();\n    let centerArea = centerX + centerY * 2;\n    let imageArea = rect.width + rect.height;\n\n    // Hide thumbnail titles, else they jump in front of transitioned image.\n    showTitles = false;\n\n    // Set active breadcrumb title\n    currentTitle = images[current].getElementsByTagName('h2')[0].innerText;\n    Object.entries(images).forEach(([key, value]) => {\n      value.style.zIndex = '1';\n    });\n\n    currentImage.classList.remove('notransition');\n    currentImage.classList.remove('quicktransition');\n    images[current].style.zIndex = '99';\n    hiresScrollPos = scrollY;\n\n    (async () => {\n      // Need to wait a bit after classes are removed.\n      await sleep(10);\n      currentImage.style.transform = `translateX(${centerX - rect.left - (rect.width/2)}px) translateY(${centerY - rect.top - (rect.height/2)}px) scale(${centerArea/imageArea})`;\n      currentImage.addEventListener('transitionend', transitionHandler = () => {\n        console.log('Transition ended');\n        document.getElementsByTagName(\"body\")[0].classList.add('locked');\n      });\n    })();\n    closedGallery = false;\n  }\n\n  function showPrevious(){\n    if(current <= 0) {\n      hiresImages[0].style.transform = `translateX(${offset}px)`;\n      hiresImages[stack.length - 1].style.transform = `translateX(-${offset}px)`;\n      (async () => {\n        // sleep while animation happens\n        await sleep(200);\n        current = stack.length - 1;\n        setImagePos(current);\n        currentTitle = images[current].getElementsByTagName('h2')[0].innerText;\n      })();\n    }else{\n      hiresImages[current].style.transform = `translateX(${offset}px)`;\n      hiresImages[current - 1].style.transform = `translateX(-${offset}px)`;\n      (async () => {\n        // sleep while animation happens\n        await sleep(200);\n        current--;\n        setImagePos(current);\n        currentTitle = images[current].getElementsByTagName('h2')[0].innerText;\n      })();\n    }\n  }\n  \n  function showNext(){\n    if(current >= (stack.length - 1)) {\n      hiresImages[0].style.transform = `translateX(${offset}px)`;\n      hiresImages[stack.length - 1].style.transform = `translateX(-${offset}px)`;\n      (async () => {\n        // sleep while animation happens\n        await sleep(200);\n        current = 0;\n        setImagePos(current);\n      })();\n    }else{\n      hiresImages[current].style.transform = `translateX(-${offset}px)`;\n      hiresImages[current + 1].style.transform = `translateX(${offset}px)`;\n      (async () => {\n        // sleep while animation happens\n        await sleep(200);\n        current++;\n        setImagePos(current);\n      })();\n    }\n    \n  }\n\n  // Sets non-active gallery items to a position where they can shrink from when the hi-res gallery is closed.\n  function setImagePos(current){\n    let rect = images[current].getBoundingClientRect();\n    \n    let centerArea = centerX + centerY * 2;\n    let imageArea = rect.width + rect.height;\n    let currentImage = images[current].getElementsByTagName('img')[0];\n\n    \n    Object.entries(images).forEach(([key, value]) => {\n      value.style.zIndex = '1';\n      value.firstChild.classList.add('notransition');\n      value.firstChild.classList.remove('hitransition');\n      value.firstChild.style.transform = `translateX(0) translateY(0px) scale(1)`;\n    });\n\n    images[current].style.zIndex = '99';\n    currentImage.style.transform = `translateX(${centerX - rect.left - (rect.width/2)}px) translateY(${centerY - rect.top - (rect.height/2)}px) scale(${centerArea/imageArea})`;\n    currentTitle = images[current].getElementsByTagName('h2')[0].innerText;\n  }\n\n  function closeGallery(){\n      let currentImage = images[current].getElementsByTagName('img')[0];\n      let currentTransformPos = currentImage.style;\n      currentImage.removeEventListener('transitionend', transitionHandler ,false);\n\n      // this is tricky because we might need two offset values\n      window.scrollTo(0, hiresScrollPos);\n      document.getElementsByTagName(\"body\")[0].classList.remove('locked');\n\n      currentImage.classList.remove('notransition');\n      currentImage.classList.add('hitransition');\n\n      (async () => {\n        // wait for animation to end.\n        await sleep(200);\n        currentImage.style.transform = `translateX(0) translateY(0) scale(1)`;\n        ready = false;\n        hiresLoaded = false;\n        showTitles = true;\n      })();\n      \n      closedGallery = true;\n  }\n\n</script>\n\n<style>\n  /* TODO: Clean+optimise these a little, get rid of any globals. */\n  h2{\n    position: absolute; bottom: -50px; left: -10px;\n    font-weight: 200;\n    padding: 0.5em 0;\n    margin-left: 0.8em;\n    font-size: 0.9em;\n    color: #222;\n    opacity: 0;\n    width: 99%;\n    transition: 0s opacity;\n  }\n\n  h2:after{\n    position: relative;\n    display: block;\n    content: '';\n    height: 1px;\n    width: 100%;\n    bottom: -8px;\n    background: linear-gradient(to right, rgba(0,0,0,0.03) 0%, rgba(0,0,0,0.1) 25%,rgba(0,0,0,0.1) 55%, rgba(0,0,0,0) 100%);\n  }\n\n  .in{\n    opacity: 1;\n    transition: 0.4s 0.6s opacity;\n  }\n  .out{\n    opacity: 0 !important;\n  }\n\n  .stack{\n    position: absolute !important;\n    top: 2em; right: 2em;\n    width: calc(100vw - 4em) !important;\n    z-index: 3;\n  }\n  .stack a{\n    display: block;\n  }\n  .stack :global(img) {\n    box-shadow: 0 0 2px #ccc;\n    border-radius: 4px;\n    background: #ccc;\n  }\n  .transitioning :global(img) {\n    transition: 0s all;\n  }\n  .transitioning .magnify {\n    display: none;\n  }\n  .stack :global(.slowtransition) {\n    /* transition: all 3.6s cubic-bezier(0,0,.13,1.33) !important; */\n    transition: all 0.5s cubic-bezier(0.38, 0.56, 0.21, 1.15) !important;\n  }\n  .stack :global(.quicktransition) {\n    transition: transform 0.2s cubic-bezier(0,0,.13,1.2), opacity 0.3s ease-out !important;\n    opacity: 0.5;\n  }\n  .stack :global(.hitransition) {\n    transition: transform 0.33s cubic-bezier(0,0,.13,1.1);\n    opacity: 1;\n  }\n  .stack :global(a:first-child.quicktransition) {\n    transition: transform 0.2s cubic-bezier(0,0,.13,1.06) !important;\n    opacity: 1;\n  }\n\n  .gallery{\n    display: flex;\n    flex: 1 auto;\n    flex-flow: row wrap;\n    align-content: flex-start;\n    justify-content: center;\n  }\n\n  .gallery a{\n    position: relative;\n    margin: 1em 1.5em 3em 1.5em;\n  }\n  \n  .gallery a:hover .magnify{\n    opacity: 1;\n  }\n\n  .hires{\n    position: fixed;\n    top: 0; left: 0;\n    z-index: 99;\n    height: 100vh; width: 100vw;\n    background: #fff;\n    opacity: 0;\n    transition: 0.8s opacity;\n  }\n\n  .hires.ready{\n    opacity: 1;\n  }\n\n  .hires :global(img){\n    object-fit: contain;\n    position: absolute; top: 0;\n  }\n\n  .hires div{\n    opacity: 0;\n    transition: 0.3s all;\n    width: 100vw; height: 100vh;\n    position: absolute;\n  }\n  \n  .hires div.active{\n    opacity: 1;\n    transform: translateX(0) !important;\n  }\n\n  .previous, .next{\n    position: absolute;\n    top: calc(50vh - 60px);\n    background: rgba(255,255,255,0.05);\n    height: 120px; width: 80px;\n    cursor: pointer;\n    transition: 0.4s all;\n  }\n  .previous:hover, .next:hover{\n    background: rgba(255,255,255,0.15);\n  }\n  .previous:hover{\n    transform: translateX(-5px);\n  }\n  .next:hover{\n    transform: translateX(5px);\n  }\n  .previous:before, .previous:after, .next:before, .next:after{\n    content:'';\n    position: absolute;\n    width: 22px;\n    height: 2px;\n    background: #999;\n    right: 20px; top: 50px;\n  }\n  .previous:before{\n    transform: rotate(-45deg)\n  }\n  .previous::after{\n    transform: rotate(45deg);\n    top: 65px;\n  }\n  .next:before{\n    transform: rotate(45deg)\n  }\n  .next::after{\n    transform: rotate(-45deg);\n    top: 65px;\n  }\n  .previous{\n    left: 0;\n    border-radius: 0 20px 20px 0;\n  }\n  .next{\n    right: 0;\n    border-radius: 20px 0 0 20px;\n  }\n  .close{\n    color: #333;\n    left: 0.4em; top: 0.5em;\n    position: absolute;\n    font-weight: 300;\n    text-transform: none;\n    font-weight: bold;\n    font-size: 1.2em;\n    width: 25%; height: 40px;\n    padding-left: 18px;\n    cursor: pointer;\n  }\n  .close:before, .close:after{\n    content:'';\n    position: absolute;\n    width: 2px;\n    height: 6px;\n    background: #333;\n    left: 8px; top: 9px;\n  }\n  .close:hover:before{\n    transform: translateX(-2px); transform: rotate(45deg);\n  }\n  .close:hover:after{\n    transform: translateX(-2px); transform: rotate(-45deg);\n  }\n  .close:before{\n    transform: rotate(45deg);\n  }\n  .close:after{\n    transform: rotate(-45deg);\n    top: 12px;\n  }\n  .magnify{\n    width: 100%;\n    background-color: var(--bgcolortint);\n    height: 100%;\n    position: absolute; bottom: 0; right: 0;\n    opacity: 0;\n    transition: 0.3s opacity;\n  }\n  .magnify.out{\n    transition: 0s opacity;\n  }\n  .magnify:before{\n    content: '';\n    position: absolute;\n    right: calc(50% - 22px);\n    bottom: calc(50% - 16px);\n    width: 14px;\n    height: 4px;\n    background: #fff;\n    transform: rotate(45deg);\n  }\n  .magnify:after{\n    content: '';\n    width: 32px;\n    height: 32px;\n    border-radius: 50%;\n    border: 4px solid #fff;\n    position: absolute; left: calc(50% - 24px); top: calc(50% - 22px);\n    z-index: 9;\n  }\n  \n</style>\n\n<svelte:window bind:scrollY={y} on:keydown={handleKeydown}/>\n  <div class=\"stack gallery\" bind:this={activeCollection} >\n    {#each stack as image, index}\n      <a class:transitioning=\"{transitioning === true}\" class=\"galleryitem\" href=\"{hiresdir}/{image.src}\" on:click={e => loadLargeImages(e, index)}> \n        <Image image=\"{lowresdir}/{image.src}\" on:loadingComplete />\n        <span class:out=\"{showTitles === false}\" class=\"magnify\"></span>\n        <h2 class:out=\"{$destroyingExpandedGallery === true || showTitles === false}\" class:in=\"{$loadingSecondary === false && showTitles !== false && !$destroyingExpandedGallery}\">\n          {image.name}\n        </h2>\n      </a>\n    {/each}\n  </div>\n\n{#if ready}\n  {#if !hiresLoaded}\n    <Spinner />\n  {/if}\n  <div class=\"hires\" class:ready=\"{hiresLoaded === true}\" out:fade=\"{{duration: 100}}\" bind:this={thirdLevel}>\n    {#each stack as image, index}\n      <div class:active=\"{current === index}\" class=\"hi-image\" >\n        <Image image=\"{hiresdir}/{image.src}\" on:loadingComplete={handleLoadingHiResComplete}/>\n      </div>\n    {/each}\n    <span class=\"previous\" on:click={showPrevious}></span>\n    <span class=\"next\" on:click={showNext}></span>\n    <span class=\"close\" on:click={closeGallery}>{currentTitle}</span>\n  </div>\n{/if}","<script context=\"module\">\n  // TODO: refactor. also, keyboard navigation: make outline/hotspots consistent/prettier.\n  // add dark mode.\n  // for wizardry to keep tabs on the collections\n  const elements = new Set();\n  //export let _resetStacks;\n</script>\n\n<script>\n  // This component shows a cover image with dummy images (spans) behind to \n  // give an indication of gallery/stack quantity\n  // The stack also splays out slightly on-hover.\n\n  // We're also have a child component in here which loads & shows all images from the user-selected stack.\n  import Image from './Image.svelte';\n  import Spinner from './Spinner.svelte';\n  import GalleryExpanded from './GalleryExpanded.svelte';\n  import { onMount, createEventDispatcher } from 'svelte';\n  import { fly, fade } from 'svelte/transition';\n  import { activeCollection, destroyingExpandedGallery, loadingSecondary } from './stores.js';\n  \n  export let imagecollection;\n  export let lowresdir;\n  export let hiresdir;\n  export let id = 0;\n  export let name;\n  export let color;\n\n  const dispatch = createEventDispatcher();\n  const sleep = msec => new Promise(resolve => setTimeout(resolve, msec));\n\n  // placeholders for objects that we'll iterate over\n  let collection;\n  let galleryExpanded;\n  let fakeImages;\n  let firstImage;\n\n  // reference to orginal colour\n  let originalbgcolor;\n\n  // count for loading\n  let count = 0;\n  \n  // booleans\n  let attemptingtoLoad = false;\n\n  onMount(() => {\n\t\tfakeImages = collection.getElementsByTagName('div');\n    firstImage = collection.getElementsByTagName('img')[0];\n    \n    // some wizardry for keeping tabs on the collections\n    elements.add(collection);\n\t\treturn () => elements.delete(collection);\n  });\n  \n  \n  // Rotate image stack on hover over\n  function rotate() {\n    //collection.style.transform = 'rotate(-1.5deg)';\n    Object.entries(fakeImages).forEach(([key, value]) => {\n      value.style.transform = 'rotate(' + ((parseInt(key)* 4) + 5)+ 'deg)';\n    })\n    firstImage.style.transform = 'scale(1.03) translateY(5px) rotate(-1deg)';\n  }\n\n  // Un-Rotate image stack on hover out\n  function unRotate() {\n    //collection.style.transform = 'rotate(0deg)';\n    Object.entries(fakeImages).forEach(([key, value]) => {\n      value.style.transform = 'rotate(' + (2 * (parseInt(key)+ 1))+ 'deg)';\n    })\n    firstImage.style.transform = 'scale(1) rotate(0deg)';\n  }\n\n  // Initiate the gallery and expand the stack\n  function showContents(event){\n    attemptingtoLoad = true;\n    event.preventDefault();\n\n    originalbgcolor = getComputedStyle(document.documentElement).getPropertyValue('--bgcolor');\n    if(color){\n      \n      let hslcolor = color.split(\",\");\n\n      // Can I do this automatically to find the primary color of the image?\n      document.documentElement.style.setProperty('--bgcolor', `hsla(${hslcolor[0]}, ${hslcolor[1]}%, ${hslcolor[2]}%, 1)`);\n      document.documentElement.style.setProperty('--bgcolortint', `hsla(${hslcolor[0]}, ${hslcolor[1]}%, ${hslcolor[2]}%, 0.6)`);\n      document.documentElement.style.setProperty('--bgcolordarktint', `hsl(${hslcolor[0]}, ${hslcolor[1]}%, ${hslcolor[2]/hslcolor[1] * 10}%)`);\n    }\n\n    // this sets the loading to true.\n    loadingSecondary.update(n => true);\n    \n    // sets which stack needs to be expanded.\n    activeCollection.update(n => id);\n    blowStacks();\n  }\n\n  // Blow away the other stacks when we're initiating an Expanded Gallery\n  function blowStacks(){\n    \n    let centerX = document.documentElement.clientWidth/2;\n    let centerY = document.documentElement.clientHeight/2;\n    \n    elements.forEach(element => {\n      var rect = element.getBoundingClientRect();\n      element.classList.add('neardeath');\n      let myId = parseInt(element.dataset.id);\n      element.classList.add('no-pointer-events');\n      if(myId!==$activeCollection){\n        element.style.transform = `translateX(${rect.left/3 - centerX/3}px) translateY(${rect.top/3 - centerY/3}px)`\n      }\n    });\n\n  }\n\n  // Function for bringing the stacks back after we've closed an Expanded Gallery\n  function resetStacks(){\n    console.log('resetting...');\n    \n    document.documentElement.style.setProperty('--bgcolor', originalbgcolor);\n    \n    // Tells the expanded gallery that we're about to destroy it, so we can then call the consolitateStuff() function.\n    // might be able to call the funtion directly instead of this??\n    destroyingExpandedGallery.update(n => true);\n\n    elements.forEach(element => {\n      element.classList.remove('neardeath'); \n    });\n    \n    (async () => {\n      await sleep(200);\n      activeCollection.update(n => 0);\n      attemptingtoLoad = false;\n\n      elements.forEach(element => {\n        element.style.transform = `translateX(0px) translateY(0px)` \n      });\n\n    })();\n    (async () => {\n      await sleep(600);\n      elements.forEach(element => {\n        element.classList.remove('no-pointer-events');\n      });\n    })();\n  }\n  \n  // Wanted to maybe have a loader, so the following will let us know when all\n  // Image components in an Expanded Gallery have loaded.\n  function handleLoadingComplete(event) {\n    count = count + event.detail.loadingComplete;\n    if(count === imagecollection.length){\n      \n      console.log(\"Loading complete\");\n      loadingSecondary.update(n => false);\n\n      count = 0;\n    }\n  }\n</script>\n\n<style>\n  /* These refer to the darkness class, none or total */\n  h2{\n    position: absolute; bottom: -60px; left: -10px;\n    font-weight: 200;\n    padding: 0.5em 0 0.5em 0.5em;\n    margin-left: 0.8em;\n    font-size: 0.9em;\n    color: #222;\n    display: block;\n    width: 99%;\n  }\n  h2:after{\n    position: relative;\n    display: block;\n    content: '';\n    height: 1px;\n    width: 100%;\n    bottom: -8px;\n    background: linear-gradient(to right, rgba(0,0,0,0.03) 0%, rgba(0,0,0,0.1) 25%,rgba(0,0,0,0.1) 55%, rgba(0,0,0,0) 100%);\n  }\n  h2 span{\n    display: block;\n    color: #a9a9a9;\n    font-size: 0.8em\n  }\n  .collection.active{\n    z-index: 2 !important;\n    opacity: 0.6;\n  }\n  .collection.nonactive{\n    opacity: 0;\n    pointer-events: none;\n  }\n\n  .dummyimage{\n    border: 1px solid #d6d6d6;\n    background: rgba(255,255,255,0.8);\n    border-radius: 4px;\n    display: block;\n    width: 100%;\n    height: 100%;\n    position: absolute; top: 0; left: 0;\n    transition: 0.15s transform ease-out;\n  }\n\n  .collection:hover span{\n    transition: 0.3s transform ease-out;\n  }\n\n  .collection{\n    position: relative;\n    transition: 0.2s all ease-out;\n  }\n\n  .collection:hover{\n    transition: 0.3s all ease-out;\n  }\n\n  .collection :global(img) {\n    position: absolute;\n    top: 0; left: 0;\n    box-shadow: 0 0 2px #ccc;\n    /* transition: 0.15s all ease-out; */\n    border-radius: 4px;\n  } \n\n  .collection:hover :global(img){\n    transition: 0.3s all ease-out;\n  }\n\n  .collection :global(img:first-child){\n    box-shadow: 0px 1px 3px rgba(90,90,90, 0.3)\n  }\n  .collection:hover :global(img:first-child){\n    box-shadow: 0px -5px 30px rgba(90,90,90, 0.3)\n  }\n\n  .breadcrumb{\n    opacity: 1;\n    position: fixed;\n    top: 0; left: 0;\n    width: 100vw; height: 20px;\n    z-index: 99;\n    padding: 10px;\n    cursor: pointer;\n    font-weight: bold;\n    font-size: 1.2em;\n  }\n    .breadcrumb p{\n      margin: 0;\n      position: relative;\n      display: block;\n      color: #333;\n      padding-left: 16px;\n      text-transform: none;\n    }\n    .breadcrumb p:before, .breadcrumb p:after{\n      content: '';\n      display: block;\n      position: absolute;\n      left: 6px; top: 9px;\n      height: 6px; width: 2px;\n      background: currentColor;\n      transform: rotate(45deg);\n      transition: 0.3s all;\n    }\n    .breadcrumb p span{\n      text-transform: none;\n      font-weight: 300;\n      color: rgba(255,255,255,0.9);\n      font-size: 0.9em;\n    }\n    .breadcrumb p:hover:before{\n      transform: translateX(-2px) rotate(45deg);\n    }\n    .breadcrumb p:hover:after{\n      transform: translateX(-2px) rotate(-45deg);\n    }\n    .breadcrumb p:after{\n      top: 12px;\n      transform: rotate(-45deg);\n    }\n\n  .loading--false{\n    opacity: 1;\n    pointer-events: auto;\n  }\n  .loading--true{\n    opacity: 0;\n    pointer-events: none;\n  }\n\n  \n  \n</style>\n\n{#if $activeCollection == id}\n  <div id=\"breadcrumb\" class=\"breadcrumb\" on:click={resetStacks} in:fly=\"{{ y: -40, duration: 400 }}\" out:fly=\"{{ y: -40, duration: 400 }}\" >\n    <p>{name}</p>\n  </div>\n{/if}\n\n<a href=\"{hiresdir}/{imagecollection[0].src}\" class:active=\"{id === $activeCollection && $loadingSecondary == true}\" \n     class:nonactive=\"{$activeCollection!== 0 && id !== $activeCollection}\" \n     class=\"collection\" \n     data-id={id} \n     bind:this={collection} \n     on:mouseenter={rotate} \n     on:mouseleave={unRotate} \n     on:click={showContents}>\n\n  <!-- in case we want a spinner  -->\n  {#if $activeCollection == id}\n    <Spinner />\n  {/if}\n  <!-- Initial Stacked Gallery, we only load the first image -->\n  {#each imagecollection as image, index}\n    {#if index==0}\n      <Image image=\"{lowresdir}/{image.src}\" />\n    {:else}\n      <div class=\"dummyimage\" style=\"transform: rotate({index * 2}deg); z-index: -{index}; opacity: {1 - 1/imagecollection.length * index/1.2}\"></div>\n    {/if}\n  {/each}\n  <h2>\n    {name}\n    <span>({imagecollection.length} Images)</span>\n  </h2>\n</a>\n\n<!-- Real Gallery, we load all images and then it can be expanded -->\n{#if attemptingtoLoad}\n  <!-- {@debug imagecollection} -->\n   <div class=\"loading--{$loadingSecondary}\">\n    <GalleryExpanded bind:this={galleryExpanded} lowresdir={lowresdir} hiresdir={hiresdir} stack={imagecollection} originaltarget={collection} on:loadingComplete=\"{handleLoadingComplete}\"  />\n  </div>\n{/if}","<script>\n\texport let name;\n\timport GalleryStack from './GalleryStack.svelte';\n\timport { fly } from 'svelte/transition';\n\timport { activeCollection } from './stores.js';\n\n\tlet uid = 1;\n\tlet menuHover = false;\n\tlet about = false;\n\t// Images, maybe I can make this easier somehow?\n\t// Auto-generate from a directory structure maybe?\n\t// let collection0 = [\n\t// \t{ src: '01_front_cover.jpg', name: 'Noa' },\n\t// \t{ src: '02_back_cover.jpg', name: 'Dog' },\n\t// \t{ src: 'racoon_together.jpg', name: 'Glass' }\n\t// ];\n\tlet collection1 = [\n\t\t{ src: 'Noa.JPG', name: 'Noa' },\n\t\t{ src: 'dog.JPG', name: 'Dog' },\n\t\t{ src: 'glass.JPG', name: 'Glass' }\n\t];\n\t\n\tlet collection4 = [\n\t\t{ src: 'atami.JPG', name: 'Atami at night' },\n\t\t{ src: 'kenodo.JPG', name: 'Konodo Highway' },\n\t\t{ src: 'kenodo2.JPG', name: 'Tunnels' }\n\t];\n\tlet collection6 = [\n\t\t{ src: 'boring.JPG', name: 'Everything is boring' },\n\t\t{ src: 'hownotto.JPG', name: 'How not to draw' },\n\t\t{ src: 'isometric.JPG', name: 'Isometric' },\n\t\t{ src: 'notes.JPG', name: 'Notes' },\n\t\t{ src: 'glass-b+w.JPG', name: 'Glass' }\n\t];\n\tlet collection2 = [\n\t\t{ src: 'cash.JPG', name: 'Cash suitcase' },\n\t\t{ src: 'robo.JPG', name: 'Robot' },\n\t\t{ src: 'tako.JPG', name: 'Octopus' }\n\t];\n\tlet collection5 = [\n\t\t{ src: 'angrykid2.JPG', name: 'Angry 1' },\n\t\t{ src: 'angrykid1.JPG', name: 'Angry 2' },\n\t\t{ src: 'angrykid3.JPG', name: 'Angry 3' },\n\t\t{ src: 'angrykid4.JPG', name: 'Angry 4' },\n\t\t{ src: 'angrykid5.JPG', name: 'Angry 5' }\n\t];\n\tlet collection3 = [\n\t\t{ src: 'citizens.JPG', name: 'Citizens of science' },\n\t\t{ src: 'screwit.JPG', name: 'Screw It' },\n\t\t{ src: 'boltit.JPG', name: 'Boltman' },\n\t\t{ src: 'kumo.JPG', name: 'Spiderdeath' }\n\t];\n\n\tfunction handleHover(){\n\t\tif(menuHover){\n\t\t\tmenuHover = false;\n\t\t}else{\n\t\t\tmenuHover = true;\n\t\t}\n\t}\n\n\tfunction handleAbout(event){\n\t\tevent.preventDefault();\n\t\tif(about){\n\t\t\tabout = false;\n\t\t}else{\n\t\t\tabout = true;\n\t\t}\n\t}\n\n</script>\n\n<style>\n\t.container{\n\t\tdisplay: flex;\n\t\tflex: 1 auto;\n\t\tflex-basis: 15%;\n\t\tflex-flow: row wrap;\n\t\talign-content: flex-start;\n\t\tjustify-content: center;\n\t\tvertical-align: middle;\n\t\t\n\t\twidth: auto;\n\t\tmargin: 40px 1em 1em;\n\t}\n\t.container .links{\n\t\talign-self: center;\n\t\tpadding: 0 24px;\n\t\tcolor: #929292;\n\t\tfont-weight: 200;\n\t\ttext-decoration: none;\n\t\topacity: 0;\n\t\tposition: relative; top: -4px;\n\t\ttransition: 0.8s opacity;\n\t}\n\t.container .links.hovering{\n\t\topacity: 1;\n\t}\n\t.menu{\n\n\t}\n\t/* Experimenting with css grid...\n\t .container{\n\t\tdisplay: grid;\n\t\tgrid-template-columns: 1fr 1fr 1fr;\n\t\tgrid-template-areas: \"a a b\"\n\t\t\t\t\t\t\t\t\t\t\t\t \"c d e\"\n\t\t\t\t\t\t\t\t\t\t\t\t \"f g h\";\n\n\t\talign-content: flex-start;\n\t\tjustify-content: center;\n\t\twidth: auto;\n\t\tmargin: 40px 1em 1em;\n\t} \n\t.container :global(.collection) {\n\t\twidth: calc(100% - 3em);\n\t\tmargin: 0em 1.5em 6em 1.5em;\n\t\theight: 15em;\n\t}\n\t.container :global(.collection:first-child) {\n\t\tgrid-area: a;\n\t\theight: calc(100% - 6em);\n\t}\n\t.container :global(.galleryitem) {\n\t\twidth: calc(19em - 3em);\n\t\tmargin: 0em 1.5em 6em 1.5em;\n\t\theight: 15em;\n\t}\n\t*/\n\t.container :global(.collection, .galleryitem) {\n\t\twidth: calc(100% - 3em);\n\t\tmin-width: 16em;\n\t\tmargin: 0em 1.5em 6em 1.5em;\n\t\theight: 15em;\n\t}\n\n\t.stacks-logo{\n\t\tdisplay: inline-block;\n\t\tpadding: 15px 7px 8px;\n\t\tposition: relative;\n\t}\n\t.stacks-logo svg{\n\t\tposition: relative;\n\t\tz-index: 2;\n\t\tfill: var(--dark);\n\t\ttransition: 0.3s all;\n\t}\n\t.stacks-logo:before{\n\t\tcontent: '';\n\t\tdisplay: block;\n\t\tbackground: rgba(151,151,151, 0.23);\n\t\twidth: 100%; height: 100%;\n\t\ttransform: rotate(13deg);\n\t\tz-index: 1;\n    position: absolute;\n    top: 0;\n    left: 0;\n\t\tborder-radius: 3px; \n\t\ttransition: 0.3s all;\n\t}\n\t.stacks-logo:after{\n\t\tcontent: '';\n\t\tdisplay: block;\n\t\tbackground: var(--light);\n\t\tborder: 1px solid rgba(151,151,151, 0.23);\n\t\twidth: 100%; height: 100%;\n\t\ttransform: rotate(0deg);\n\t\tz-index: 1;\n    position: absolute;\n    top: 0;\n    left: -1px;\n\t\tborder-radius: 3px; \n\t\ttransition: 0.3s all;\n\t}\n\t.stacks-logo:hover:before,\n\t.stacks-logo.hovering:before{\n\t\ttransform: rotate(0deg);\n\t}\n\t.stacks-logo:hover:after,\n\t.stacks-logo.hovering:after{\n\t\tbackground: var(--dark);\n\t\ttransform: rotate(-5deg);\n\t}\n\t.stacks-logo:hover svg,\n\t.stacks-logo.hovering svg{\n\t\tfill: var(--light);\n\t}\n\t@media(min-width: 420px){\n\t\t.container :global(.collection, .galleryitem) {\n\t\t\twidth: calc(22vw - 3em);\n\t\t}\n\t}\n\n\t.about{\n\t\tbackground: var(--dark);\n\t\tcolor: var(--light);\n\t\twidth: 100vw;\n\t\theight: 100vh;\n\t\tposition: fixed; top: 0; left: 0;\n\t}\n\t.about p{\n\t\tfont-weight: 200;\n\t\ttext-align: center;\n\t\twidth: 40%;\n\t\tmax-width: 800px;\n\t\tpadding-top: 140px;\n\t\tmargin: auto;\n\t}\n</style>\n<div class=\"container\" style=\"height: 50px; margin-bottom: 20px; margin-top: 25px\">\n{#if $activeCollection==0}\n\t<div class=\"menu\" on:mouseenter=\"{handleHover}\" on:mouseleave=\"{handleHover}\">\n\t\t<a on:click=\"{handleAbout}\" class:hovering=\"{menuHover === true}\" class=\"links\" href=\"about\">About</a>\n\t\t<div class:hovering=\"{menuHover === true}\" class=\"stacks-logo\" in:fly=\"{{ y: -50, duration: 400 }}\" out:fly=\"{{ y: -50, duration: 400 }}\">\n\t\t\t<svg width=\"65px\" height=\"24px\" viewBox=\"0 0 65 24\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n\t\t\t\t\t<g transform=\"translate(-12.000000, -22.000000)\" fill-rule=\"nonzero\">\n\t\t\t\t\t\t<path d=\"M28.664,22.376 C30.152,22.376 31.784,23.72 31.784,25.28 C31.784,27.464 28.424,31.616 26.768,31.616 C26.144,31.616 25.064,30.68 25.064,30.152 C25.064,29.6 25.88,28.88 26.624,28.16 C27.32,27.464 27.656,26.792 27.896,26.792 C28.136,26.792 28.904,27.632 28.904,27.632 C29.576,27.056 30.44,26.024 30.44,25.064 C30.44,24.728 30.032,24.296 29.648,24.296 C26.648,24.296 21.224,28.376 21.224,31.112 C21.224,33.512 27.44,34.304 27.44,37.616 C27.44,41.576 22.64,45.464 18.368,45.464 C15.44,45.464 12.8,42.344 12.8,41.792 C12.8,41.48 13.04,41.144 13.328,41.144 C13.544,41.144 15.104,42.968 17.648,42.968 C20.864,42.968 24.2,40.136 24.2,37.472 C24.2,34.448 18.488,34.016 18.488,30.08 C18.488,26.36 24.632,22.376 28.664,22.376 Z M32.624,41.312 C31.04,41.312 28.904,39.992 28.904,38.096 C28.904,36.536 30.032,33.896 31.184,31.568 C30.56,31.304 30.176,30.728 30.176,30.488 C30.176,30.344 30.344,30.152 30.488,30.152 C30.656,30.152 30.92,30.416 31.736,30.488 C32.72,28.568 33.584,27.032 33.584,26.816 C33.584,26.624 33.632,26.456 33.848,26.456 C34.472,26.456 35.504,27.344 35.504,28.28 C35.504,28.904 35.288,29.12 34.544,30.44 C35.576,30.392 36.512,30.32 36.728,30.32 C37.112,30.32 37.208,30.392 37.208,30.632 C37.208,30.872 36.512,32.048 35.624,32.048 C35.216,32.048 34.496,32 33.776,31.928 L32.96,33.656 C31.472,36.896 31.352,38.024 31.352,38.528 C31.352,39.296 31.664,39.92 32.48,39.92 C33.488,39.92 35.168,37.856 36.152,36.488 C36.56,35.912 36.68,35.72 36.8,35.72 C36.992,35.72 37.376,36.296 37.376,36.656 C37.376,37.016 37.28,37.304 36.776,37.952 C35.864,39.152 34.232,41.312 32.624,41.312 Z M44.384,41.192 C43.328,41.192 42.392,40.616 41.984,39.944 C41.84,39.68 41.816,39.224 41.816,38.912 L41.816,38.6 C41.816,38.6 40.016,41.336 38.504,41.336 C37.016,41.336 35.624,39.728 35.624,38.36 C35.624,35.816 39.344,30.848 41.768,30.848 C42.872,30.848 44.096,31.904 44.096,32.696 C44.096,32.696 44.456,32.456 44.648,32.456 C45.152,32.456 46.352,33.248 46.352,33.584 C46.352,33.92 44.888,35.696 44.312,37.472 C44,38.432 43.928,38.96 43.928,39.2 C43.928,39.584 44.288,39.8 44.6,39.8 C45.104,39.8 46.736,37.856 47.72,36.488 C48.128,35.912 48.248,35.72 48.368,35.72 C48.56,35.72 48.944,36.296 48.944,36.656 C48.944,37.016 48.848,37.304 48.344,37.952 C47.432,39.152 45.896,41.192 44.384,41.192 Z M42.272,32.888 C41.144,32.888 37.904,37.4 37.904,39.392 C37.904,39.752 38.216,39.944 38.552,39.944 C39.104,39.944 41.168,37.712 42.056,36.152 C41.984,36.032 41.912,35.96 41.912,35.792 C41.912,35.384 42.872,34.592 42.872,33.464 C42.872,33.104 42.584,32.888 42.272,32.888 Z M51.992,41.336 C49.88,41.336 47.576,39.896 47.576,37.232 C47.576,34.64 50.792,30.944 52.976,30.944 C54.392,30.944 55.52,32.024 55.52,32.96 C55.52,34.04 54.656,36.008 54.056,36.008 C53.456,36.008 52.904,35.408 52.904,35.24 C52.904,35.168 52.976,35.072 53.12,34.928 C53.552,34.496 54.248,33.584 54.248,32.912 C54.248,32.696 54.104,32.6 53.936,32.6 C52.544,32.6 50.24,35.84 50.24,37.88 C50.24,39.104 51.08,39.992 52.112,39.992 C53.528,39.992 55.232,37.856 56.216,36.488 C56.624,35.912 56.744,35.72 56.864,35.72 C57.056,35.72 57.44,36.296 57.44,36.656 C57.44,37.016 57.344,37.304 56.84,37.952 C55.928,39.152 54.2,41.336 51.992,41.336 Z M62.816,32.264 C61.976,32.264 59.264,36.032 58.904,37.04 C60.728,37.04 63.128,34.304 63.128,32.672 C63.128,32.408 63.056,32.264 62.816,32.264 Z M62.384,41.528 C59.864,41.528 59.12,38.624 58.208,38.552 C58.208,38.552 57.248,40.568 57.2,41.024 C57.176,41.288 56.936,41.408 56.72,41.408 C56.504,41.408 55.208,41.096 55.208,40.16 C55.208,39.224 55.448,38.192 57.2,33.608 C58.952,29.024 59.96,27.08 59.96,26.696 C59.96,26.528 60.104,26.48 60.344,26.48 C60.584,26.48 62.048,27.104 62.048,27.584 C62.048,28.064 60.632,30.92 59.312,34.52 C59.84,33.968 61.568,31.112 63.008,31.112 C64.448,31.112 65.144,32.072 65.144,33.776 C65.144,36.104 62.768,37.688 60.872,38.072 C62,38.576 62.288,39.512 62.984,39.512 C64.016,39.512 65.336,37.856 66.32,36.488 C66.728,35.912 66.848,35.72 66.968,35.72 C67.16,35.72 67.544,36.296 67.544,36.656 C67.544,37.016 67.448,37.304 66.944,37.952 C66.032,39.152 63.992,41.528 62.384,41.528 Z M64.664,38.792 C64.664,38.168 65.192,37.448 65.744,37.28 C66.872,35.672 68.36,33.824 69.296,32.216 C69.752,30.464 70.592,28.76 71.168,28.76 C72.104,28.76 73.112,29.504 73.112,30.272 C73.112,30.848 72.08,32.072 71.264,33.128 C71.264,35.048 72.704,35.336 72.704,38.072 C72.704,38.456 72.536,38.936 72.536,38.936 C73.664,38.24 74.576,37.28 75.152,36.488 C75.56,35.912 75.68,35.72 75.8,35.72 C75.992,35.72 76.376,36.296 76.376,36.656 C76.376,37.016 76.256,37.256 75.752,37.952 C74.336,39.896 71.864,41.384 69.224,41.384 C66.656,41.384 64.664,39.992 64.664,38.792 Z M66.776,38.216 C66.776,38.744 67.64,39.848 68.456,39.848 C69.344,39.848 69.968,38.696 69.968,37.232 C69.968,35.744 69.8,33.776 69.8,33.776 C68.96,35.096 67.952,36.608 66.776,38.216 Z\" id=\"Stacks\"></path>\n\t\t\t\t\t</g>\n\t\t\t</svg>\n\t\t</div>\n\t\t<a class:hovering=\"{menuHover === true}\" target=\"_blank\" class=\"links\" href=\"https://github.com/cssandstuff/portfolio-scaffold\">Github</a>\n\t</div>\n{/if}\n</div>\n\n<div class=\"container\">\n\t<!-- <GalleryStack width=\"\" name=\"Ongakukai\" color=\"44, 47, 90\" lowresdir=\"images/16_ongakukai\" hiresdir=\"images/16_ongakukai/originals\" imagecollection={collection0} id=\"{uid++}\" /> -->\n\t<GalleryStack width=\"\" name=\"Painterly\" color=\"261, 27, 71\" lowresdir=\"images\" hiresdir=\"images/originals\" imagecollection={collection1} id=\"{uid++}\" />\n\t<GalleryStack width=\"\" name=\"Splashes\" color=\"206, 69, 88\" lowresdir=\"images\" hiresdir=\"images/originals\" imagecollection={collection2} id=\"{uid++}\" />\n\t<GalleryStack width=\"\" name=\"Citizens of science\" color=\"182, 37, 73\" lowresdir=\"images\" hiresdir=\"images/originals\" imagecollection={collection3} id=\"{uid++}\" />\n\t<GalleryStack width=\"\" name=\"Travelling\" color=\"209, 25, 24\" lowresdir=\"images\" hiresdir=\"images/originals\" imagecollection={collection4} id=\"{uid++}\" />\n\t<GalleryStack width=\"\" name=\"Angry at kids\" color=\"13, 92, 87\" lowresdir=\"images\" hiresdir=\"images/originals\" imagecollection={collection5} id=\"{uid++}\" />\n\t<GalleryStack width=\"\" name=\"Sketches\" color=\"109, 0, 76\" lowresdir=\"images\" hiresdir=\"images/originals\" imagecollection={collection6} id=\"{uid++}\"  />\n</div>\n{#if about }\n<div on:click={handleAbout} class=\"about\" in:fly=\"{{ y: -20, duration: 400 }}\" out:fly=\"{{ y: 0, duration: 400 }}\">\n<p>This started out as a small code challenge to learn Svelte v3 & to see if I could build a procreate-like gallery.</p>\n<p>I'm hopefully going to move it into Sapper and see if I can transition between routes.</p>\n</div>\n{/if}","import App from './App.svelte';\n\nconst app = new App({\n\ttarget: document.body\n});\n\nexport default app;"],"names":["noop","identity","x","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","subscribe","component","store","callback","unsub","$$","on_destroy","push","unsubscribe","is_client","window","now","performance","Date","raf","requestAnimationFrame","tasks","Set","stylesheet","running","run_tasks","task","delete","size","loop","promise","Promise","fulfil","add","[object Object]","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","destroy_each","iterations","detaching","i","length","d","element","name","document","createElement","text","data","createTextNode","space","empty","listen","event","handler","options","addEventListener","removeEventListener","set_data","set_style","key","value","style","setProperty","toggle_class","toggle","classList","current_component","active","current_rules","create_rule","duration","delay","ease","uid","step","keyframes","p","t","rule","str","hash","charCodeAt","head","sheet","insertRule","cssRules","animation","delete_rule","split","filter","anim","indexOf","join","deleteRule","set_current_component","get_current_component","Error","onMount","on_mount","createEventDispatcher","type","detail","callbacks","e","createEvent","initCustomEvent","custom_event","slice","call","dirty_components","resolved_promise","resolve","update_scheduled","binding_callbacks","render_callbacks","flush_callbacks","add_binding_callback","add_render_callback","flush","seen_callbacks","shift","update","pop","has","fragment","dirty","before_render","ctx","after_render","outros","wait","then","group_outros","remaining","check_outros","on_outro","create_in_transition","params","animation_name","config","cleanup","go","easing","tick","tick$$1","css","start_time","end_time","abort","now$$1","started","create_out_transition","group","reset","mount_component","m","new_on_destroy","map","make_dirty","init","instance","create_fragment","not_equal$$1","prop_names","parent_component","props","not_equal","bound","context","Map","ready","hydrate","l","Array","from","childNodes","c","intro","SvelteComponent","this","$destroy","index","splice","visible","image","dispatch","async","res","fetch","status","url","loader","Image","onload","loadingComplete","src","writable","start","stop","subscribers","set","new_value","s","invalidate","subscriber","destroyingExpandedGallery","activeCollection","loadingSecondary","cubicOut","f","fade","o","getComputedStyle","opacity","fly","y","target_opacity","transform","od","u","lowresdir","showTitles","$destroyingExpandedGallery","$loadingSecondary","hiresdir","transitioning","click_handler","hiresLoaded","stack","currentTitle","showPrevious","showNext","closeGallery","handleLoadingHiResComplete","current","handleKeydown","offset","thirdLevel","images","hiresImages","originalScrollPos","hiresScrollPos","transitionHandler","originaltarget","centerX","documentElement","clientWidth","centerY","clientHeight","count","expandedOnce","closedGallery","sleep","msec","setTimeout","loadLargeImages","preventDefault","currentImage","getElementsByTagName","rect","getBoundingClientRect","centerArea","imageArea","width","height","innerText","entries","zIndex","remove","scrollY","left","top","console","log","animateClicked","attemptToConsolidate","undefined","performConsolidation","imageDivRect","transformedStyle","scrollTo","setImagePos","firstChild","getElementsByClassName","onDestroy","n","code","getElementById","click","resetStacks","imagecollection","collection","handleLoadingComplete","$activeCollection","id","rotate","unRotate","showContents","attemptingtoLoad","elements","color","galleryExpanded","fakeImages","firstImage","originalbgcolor","parseInt","getPropertyValue","hslcolor","myId","dataset","blowStacks","menuHover","handleAbout","handleHover","collection1","collection2","collection3","collection4","collection5","collection6","about","body"],"mappings":"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"}